name: Create Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag name for release (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: read
  issues: read

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get tag name
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Get Previous Tag
        id: previoustag
        run: |
          # Get the previous tag (before current one)
          CURRENT_TAG="${{ steps.tag.outputs.tag }}"
          PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "^${CURRENT_TAG}$" | head -n 1)
          
          if [ -z "$PREVIOUS_TAG" ]; then
            echo "‚ö†Ô∏è  No previous tag found - this is the first release"
            echo "tag=" >> $GITHUB_OUTPUT
            echo "exists=false" >> $GITHUB_OUTPUT
          else
            echo "üìå Previous tag: $PREVIOUS_TAG"
            echo "tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
            echo "exists=true" >> $GITHUB_OUTPUT
          fi

      - name: Build Structured Changelog
        id: structured_changelog
        uses: mikepenz/release-changelog-builder-action@v5
        with:
          configuration: |
            {
              "template": "#{{CHANGELOG}}",
              "categories": [
                {
                  "title": "## üéâ Features",
                  "labels": ["feature", "feat", "feature request", "enhancement"]
                },
                {
                  "title": "## üêõ Bug Fixes",
                  "labels": ["bug", "fix", "bugfix"]
                },
                {
                  "title": "## üìö Documentation",
                  "labels": ["documentation", "docs"]
                },
                {
                  "title": "## üîß Maintenance",
                  "labels": ["chore", "dependencies"]
                },
                {
                  "title": "## üöÄ Performance",
                  "labels": ["performance"]
                },
                {
                  "title": "## üîí Security",
                  "labels": ["security"]
                }
              ],
              "label_extractor": [
                {
                  "pattern": "^(feat|feature)(\\(.+\\))?:",
                  "target": "feature"
                },
                {
                  "pattern": "^fix(\\(.+\\))?:",
                  "target": "bug"
                },
                {
                  "pattern": "^docs?(\\(.+\\))?:",
                  "target": "documentation"
                },
                {
                  "pattern": "^chore(\\(.+\\))?:",
                  "target": "chore"
                },
                {
                  "pattern": "^perf(\\(.+\\))?:",
                  "target": "performance"
                }
              ]
            }
          fromTag: ${{ steps.previoustag.outputs.exists == 'true' && steps.previoustag.outputs.tag || '' }}
          toTag: ${{ steps.tag.outputs.tag }}
          failOnError: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate AI-Enhanced Changelog
        id: ai_changelog
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          STRUCTURED_CHANGELOG: ${{ steps.structured_changelog.outputs.changelog }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          TAG: ${{ steps.tag.outputs.tag }}
          PREV_TAG: ${{ steps.previoustag.outputs.tag }}
          REPO: ${{ github.repository }}
        with:
          script: |
            const structuredChangelog = process.env.STRUCTURED_CHANGELOG;
            const apiKey = process.env.OPENAI_API_KEY;
            const tag = process.env.TAG;
            const prevTag = process.env.PREV_TAG;
            const repo = process.env.REPO;
            
            if (!apiKey) {
              console.log('‚ö†Ô∏è  No OPENAI_API_KEY found - skipping AI enhancement');
              core.setOutput('enhanced', '');
              return;
            }
            
            // Get commit details between tags with error handling
            let commits = null;
            let commitSummary = [];
            let filesChanged = [];
            let stats = {
              commits: 0,
              files: 0,
              additions: 0,
              deletions: 0
            };
            
            try {
              console.log(`üîç Comparing ${prevTag}...${tag}`);
              const compareResult = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: prevTag,
                head: tag
              });
              commits = compareResult.data;
              
              // Extract commit messages and files changed
              commitSummary = commits.commits.map(c => ({
                message: c.commit.message,
                author: c.commit.author.name,
                files: c.files?.length || 0
              }));
              
              filesChanged = commits.files?.map(f => f.filename) || [];
              stats = {
                commits: commits.commits.length,
                files: filesChanged.length,
                additions: commits.commits.reduce((sum, c) => sum + (c.stats?.additions || 0), 0),
                deletions: commits.commits.reduce((sum, c) => sum + (c.stats?.deletions || 0), 0)
              };
              
              console.log('üìä Changes:', JSON.stringify(stats, null, 2));
            } catch (error) {
              console.log('‚ö†Ô∏è  Could not fetch commit comparison:', error.message);
              console.log('üìù Will use structured changelog only for AI enhancement');
              
              // Fallback: try to get recent commits for the current tag
              try {
                const tagCommits = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: tag,
                  per_page: 20
                });
                
                commitSummary = tagCommits.data.slice(0, 10).map(c => ({
                  message: c.commit.message,
                  author: c.commit.author.name,
                  files: 0
                }));
                
                stats.commits = tagCommits.data.length;
                console.log(`üìù Using ${stats.commits} recent commits as context`);
              } catch (fallbackError) {
                console.log('‚ö†Ô∏è  Could not fetch recent commits either:', fallbackError.message);
              }
            }
            
            try {
              const systemPrompt = [
                'You are a technical writer creating release notes for pgctl, a PostgreSQL CLI management tool written in Bash.',
                '',
                'Your task:',
                '1. Analyze the changes between releases',
                '2. Create professional, user-friendly release notes',
                '3. Highlight key improvements and their impact on users',
                '4. Keep technical accuracy while being accessible',
                '5. Use emojis appropriately for visual organization',
                '6. Group related changes together logically',
                '',
                'Format:',
                '- Start with a brief 2-3 sentence overview',
                '- Organize changes by category with clear headings',
                '- Use bullet points for clarity',
                '- Mention statistics (commits, files, lines) if provided',
                '- Keep it concise but informative'
              ].join('\n');
              
              const userPromptParts = [
                `Create release notes for ${tag}${prevTag ? ` (previous: ${prevTag})` : ''}`,
                ''
              ];
              
              // Add statistics if available
              if (stats.commits > 0) {
                userPromptParts.push('**Statistics:**');
                userPromptParts.push(`- ${stats.commits} commits`);
                if (stats.files > 0) {
                  userPromptParts.push(`- ${stats.files} files changed`);
                  userPromptParts.push(`- +${stats.additions} / -${stats.deletions} lines`);
                }
                userPromptParts.push('');
              }
              
              // Add structured changelog
              userPromptParts.push('**Structured Changelog:**');
              userPromptParts.push(structuredChangelog || 'No structured changes available');
              userPromptParts.push('');
              
              // Add commit summaries if available
              if (commitSummary.length > 0) {
                userPromptParts.push('**Recent Commits:**');
                userPromptParts.push(commitSummary.slice(0, 10).map(c => `- ${c.message.split('\n')[0]}`).join('\n'));
                userPromptParts.push('');
              }
              
              // Add files changed if available
              if (filesChanged.length > 0) {
                userPromptParts.push('**Key Files Modified:**');
                userPromptParts.push(filesChanged.slice(0, 15).join(', '));
                userPromptParts.push('');
              }
              
              userPromptParts.push('Create comprehensive release notes with an overview, categorized changes, and highlight the most important improvements for users.');
              
              const userPrompt = userPromptParts.join('\n');
              
              const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                  model: 'gpt-4o',
                  messages: [
                    {
                      role: 'system',
                      content: systemPrompt
                    },
                    {
                      role: 'user',
                      content: userPrompt
                    }
                  ],
                  temperature: 0.7,
                  max_tokens: 2500
                })
              });
              
              if (!response.ok) {
                const error = await response.text();
                throw new Error(`OpenAI API error: ${response.status} - ${error}`);
              }
              
              const data = await response.json();
              const content = data.choices?.[0]?.message?.content || '';
              
              if (content) {
                console.log('‚úÖ AI-enhanced changelog generated successfully');
                core.setOutput('enhanced', content);
              } else {
                console.log('‚ö†Ô∏è  No content returned from AI');
                core.setOutput('enhanced', '');
              }
            } catch (error) {
              console.error('‚ùå AI enhancement failed:', error.message);
              core.setOutput('enhanced', '');
            }

      - name: Prepare Final Release Notes
        id: release_notes
        uses: actions/github-script@v7
        env:
          AI_ENHANCED: ${{ steps.ai_changelog.outputs.enhanced }}
          STRUCTURED: ${{ steps.structured_changelog.outputs.changelog }}
          TAG: ${{ steps.tag.outputs.tag }}
          PREV_TAG: ${{ steps.previoustag.outputs.tag }}
          PREV_TAG_EXISTS: ${{ steps.previoustag.outputs.exists }}
          REPO: ${{ github.repository }}
        with:
          script: |
            const aiEnhanced = process.env.AI_ENHANCED;
            const structured = process.env.STRUCTURED;
            const tag = process.env.TAG;
            const prevTag = process.env.PREV_TAG;
            const prevTagExists = process.env.PREV_TAG_EXISTS === 'true';
            const repo = process.env.REPO;
            
            let body = '';
            
            if (aiEnhanced && aiEnhanced.trim()) {
              console.log('‚úÖ Using AI-enhanced changelog');
              body = aiEnhanced;
            } else if (structured && structured.trim()) {
              console.log('üìù Using structured changelog (AI unavailable)');
              body = `## üìù What's Changed\n\n${structured}`;
            } else {
              console.log('‚ÑπÔ∏è  No changelog available - using default message');
              body = `## üìù Release ${tag}\n\nThis is the initial release of pgctl.`;
            }
            
            // Add comparison link if previous tag exists
            if (prevTagExists && prevTag) {
              body += `\n\n**Full Changelog**: https://github.com/${repo}/compare/${prevTag}...${tag}`;
            } else {
              body += `\n\n**Release**: https://github.com/${repo}/releases/tag/${tag}`;
            }
            
            // Add installation section
            body += `\n\n## üöÄ Installation\n\n`;
            body += '```bash\n';
            body += `git clone https://github.com/${repo}.git\n`;
            body += `cd ${repo.split('/')[1]}\n`;
            body += './install.sh\n';
            body += '```\n';
            
            // Add documentation links
            body += '\n## üìñ Documentation\n\n';
            body += `- [README](https://github.com/${repo}/blob/main/README.md)\n`;
            body += `- [Installation Guide](https://github.com/${repo}/blob/main/docs/INSTALLATION.md)\n`;
            body += `- [Contributing](https://github.com/${repo}/blob/main/docs/CONTRIBUTING.md)\n`;
            
            core.setOutput('body', body);
            return body;

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: Release ${{ steps.tag.outputs.tag }}
          body: ${{ steps.release_notes.outputs.body }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease || false }}
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update latest tag
        uses: EndBug/latest-tag@latest
        with:
          ref: latest
          description: Latest stable release
          force-branch: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
